--- contrib/python/coverage/py3/coverage/ctracer/tracer.c	(index)
+++ contrib/python/coverage/py3/coverage/ctracer/tracer.c	(working tree)
@@ -305,7 +305,7 @@ CTracer_check_missing_return(CTracer *self, PyFrameObject *frame)
                         goto error;
                     }
                 }
-                SHOWLOG(self->pdata_stack->depth, PyFrame_GetLineNumber(frame), frame->f_code->co_filename, "missedreturn");
+                SHOWLOG(self->pdata_stack->depth, PyFrame_GetLineNumber(frame), MyFrame_GetCode(frame)->co_filename, "missedreturn");
                 self->pdata_stack->depth--;
                 self->pcur_entry = &self->pdata_stack->stack[self->pdata_stack->depth];
             }
@@ -384,7 +384,7 @@ CTracer_handle_call(CTracer *self, PyFrameObject *frame)
     }
 
     /* Check if we should trace this line. */
-    filename = frame->f_code->co_filename;
+    filename = MyFrame_GetCode(frame)->co_filename;
     disposition = PyDict_GetItem(self->should_trace_cache, filename);
     if (disposition == NULL) {
         if (PyErr_Occurred()) {
@@ -548,8 +548,8 @@ CTracer_handle_call(CTracer *self, PyFrameObject *frame)
      * re-entering a generator also.  f_lasti is -1 for a true call, and a
      * real byte offset for a generator re-entry.
      */
-    if (frame->f_lasti < 0) {
-        self->pcur_entry->last_line = -frame->f_code->co_firstlineno;
+    if (MyFrame_GetLasti(frame) < 0) {
+        self->pcur_entry->last_line = -MyFrame_GetCode(frame)->co_firstlineno;
     }
     else {
         self->pcur_entry->last_line = PyFrame_GetLineNumber(frame);
@@ -633,7 +633,7 @@ CTracer_handle_line(CTracer *self, PyFrameObject *frame)
 
     STATS( self->stats.lines++; )
     if (self->pdata_stack->depth >= 0) {
-        SHOWLOG(self->pdata_stack->depth, PyFrame_GetLineNumber(frame), frame->f_code->co_filename, "line");
+        SHOWLOG(self->pdata_stack->depth, PyFrame_GetLineNumber(frame), MyFrame_GetCode(frame)->co_filename, "line");
         if (self->pcur_entry->file_data) {
             int lineno_from = -1;
             int lineno_to = -1;
@@ -714,14 +714,14 @@ CTracer_handle_return(CTracer *self, PyFrameObject *frame)
              * f_lasti before reading the byte.
              */
             int bytecode = RETURN_VALUE;
-            PyObject * pCode = frame->f_code->co_code;
-            int lasti = frame->f_lasti;
+            PyObject * pCode = MyCode_GetCode(MyFrame_GetCode(frame));
+            int lasti = MyFrame_GetLasti(frame);
 
             if (lasti < MyBytes_GET_SIZE(pCode)) {
                 bytecode = MyBytes_AS_STRING(pCode)[lasti];
             }
             if (bytecode != YIELD_VALUE) {
-                int first = frame->f_code->co_firstlineno;
+                int first = MyFrame_GetCode(frame)->co_firstlineno;
                 if (CTracer_record_pair(self, self->pcur_entry->last_line, -first) < 0) {
                     goto error;
                 }
@@ -744,7 +744,7 @@ CTracer_handle_return(CTracer *self, PyFrameObject *frame)
         }
 
         /* Pop the stack. */
-        SHOWLOG(self->pdata_stack->depth, PyFrame_GetLineNumber(frame), frame->f_code->co_filename, "return");
+        SHOWLOG(self->pdata_stack->depth, PyFrame_GetLineNumber(frame), MyFrame_GetCode(frame)->co_filename, "return");
         self->pdata_stack->depth--;
         self->pcur_entry = &self->pdata_stack->stack[self->pdata_stack->depth];
     }
@@ -775,7 +775,7 @@ CTracer_handle_exception(CTracer *self, PyFrameObject *frame)
     */
     STATS( self->stats.exceptions++; )
     self->last_exc_back = frame->f_back;
-    self->last_exc_firstlineno = frame->f_code->co_firstlineno;
+    self->last_exc_firstlineno = MyFrame_GetCode(frame)->co_firstlineno;
 
     return RET_OK;
 }
@@ -806,14 +806,14 @@ CTracer_trace(CTracer *self, PyFrameObject *frame, int what, PyObject *arg_unuse
 
     #if WHAT_LOG
     if (what <= (int)(sizeof(what_sym)/sizeof(const char *))) {
-        ascii = MyText_AS_BYTES(frame->f_code->co_filename);
+        ascii = MyText_AS_BYTES(MyFrame_GetCode(frame)->co_filename);
         printf("trace: %s @ %s %d\n", what_sym[what], MyBytes_AS_STRING(ascii), PyFrame_GetLineNumber(frame));
         Py_DECREF(ascii);
     }
     #endif
 
     #if TRACE_LOG
-    ascii = MyText_AS_BYTES(frame->f_code->co_filename);
+    ascii = MyText_AS_BYTES(MyFrame_GetCode(frame)->co_filename);
     if (strstr(MyBytes_AS_STRING(ascii), start_file) && PyFrame_GetLineNumber(frame) == start_line) {
         logging = TRUE;
     }
@@ -930,7 +930,7 @@ CTracer_call(CTracer *self, PyObject *args, PyObject *kwds)
     }
 
     #if WHAT_LOG
-    ascii = MyText_AS_BYTES(frame->f_code->co_filename);
+    ascii = MyText_AS_BYTES(MyFrame_GetCode(frame)->co_filename);
     printf("pytrace: %s @ %s %d\n", what_sym[what], MyBytes_AS_STRING(ascii), PyFrame_GetLineNumber(frame));
     Py_DECREF(ascii);
     #endif
--- contrib/python/coverage/py3/coverage/ctracer/util.h	(index)
+++ contrib/python/coverage/py3/coverage/ctracer/util.h	(working tree)
@@ -12,6 +12,42 @@
 #undef COLLECT_STATS    /* Collect counters: stats are printed when tracer is stopped. */
 #undef DO_NOTHING       /* Define this to make the tracer do nothing. */
 
+#if PY_VERSION_HEX >= 0x030B00A0
+// 3.11 moved f_lasti into an internal structure. This is totally the wrong way
+// to make this work, but it's all I've got until https://bugs.python.org/issue40421
+// is resolved.
+#include <internal/pycore_frame.h>
+#if PY_VERSION_HEX >= 0x030B00A7
+#define MyFrame_GetLasti(f)     (PyFrame_GetLasti(f))
+#else
+#define MyFrame_GetLasti(f)     ((f)->f_frame->f_lasti * 2)
+#endif
+#elif PY_VERSION_HEX >= 0x030A00A7
+// The f_lasti field changed meaning in 3.10.0a7. It had been bytes, but
+// now is instructions, so we need to adjust it to use it as a byte index.
+#define MyFrame_GetLasti(f)     ((f)->f_lasti * 2)
+#else
+#define MyFrame_GetLasti(f)     ((f)->f_lasti)
+#endif
+
+// Access f_code should be done through a helper starting in 3.9.
+#if PY_VERSION_HEX >= 0x03090000
+#define MyFrame_GetCode(f)      (PyFrame_GetCode(f))
+#else
+#define MyFrame_GetCode(f)      ((f)->f_code)
+#endif
+
+#if PY_VERSION_HEX >= 0x030B00B1
+#define MyCode_GetCode(co)      (PyCode_GetCode(co))
+#define MyCode_FreeCode(code)   Py_XDECREF(code)
+#elif PY_VERSION_HEX >= 0x030B00A7
+#define MyCode_GetCode(co)      (PyObject_GetAttrString((PyObject *)(co), "co_code"))
+#define MyCode_FreeCode(code)   Py_XDECREF(code)
+#else
+#define MyCode_GetCode(co)      ((co)->co_code)
+#define MyCode_FreeCode(code)
+#endif
+
 /* Py 2.x and 3.x compatibility */
 
 #if PY_MAJOR_VERSION >= 3
